defmodule ETSSupervisor do
  @moduledoc """
  Module responsible to control and interact with ETSSupervisor.
  """
 
  @doc """
  Starts the server, invoked by the app supervisor.
  """
  def start_link(name) do
    :gen_server.start({ :local, name }, __MODULE__, name, [])
  end
 
  @doc """
  Lookups the an entry for the given given id.
 
  It first does a fast lookup in a ETS table then
  fallbacks to a server call which will spawn a
  new server if one does not exist.
  """
  def lookup(name, id) when is_integer(id) do
    case :ets.lookup(name, id) do
      [{ ^id, pid }] -> pid
      _ -> start(name, id, [])
    end
  end
 
  @doc """
  Manually requests a worker to be started.
  """
  def start(name, id, args // []) when is_integer(id) do
    :gen_server.call(name, { :start, id, args })
  end
 
  @doc """
  Termiante all servers, cleaning up the ets table. Used by tests.
  """
  def clear(name) do
    :gen_server.call(name, :clear)
  end
 
  ## Backend
 
  use GenServer.Behaviour
 
  @doc false
  def init(name) do
    :ets.new(name, [:set, :protected, :named_table, { :read_concurrency, true }])
    { :ok, name }
  end
 
  @doc false
  def handle_call({ :start, id, args }, _from, name) do
    case :ets.lookup(name, id) do
      [{ ^id, pid }] ->
        { :reply, pid, name }
      _ ->
        { :ok, pid } = ETSSupervisor.Spawner.start_child(name.Spawner, id, args)
        Process.monitor(pid)
        :ets.insert(name, { id, pid })
        { :reply, pid, name }
    end
  end
 
  def handle_call(:clear, _from, name) do
    lc { id, _pid } inlist :ets.tab2list(name) do
      ETSSupervisor.Spawner.terminate_child(name.Spawner, id)
      :ets.delete(name, id)
    end
 
    { :reply, :ok, name }
  end
 
  def handle_call(_msg, _from, _name) do
    super
  end
 
  @doc false
  def handle_info({ :DOWN, _ref, :process, pid, _reason }, name) do
    :ets.match_delete(name, { :_, pid })
    { :noreply, name }
  end
 
  def handle_info(_msg, _name) do
    super
  end
end
 
defmodule ETSSupervisor.Spawner do
  @moduledoc false
 
  use Supervisor.Behaviour
 
  def start_link(spawner, spawned) do
    :supervisor.start_link({ :local, spawner }, __MODULE__, spawned)
  end
 
  def start_child(spawner, id, args) do
    :supervisor.start_child(spawner, [id|args])
  end
 
  def terminate_child(spawner, id) do
    :supervisor.terminate_child(spawner, id)
  end
 
  def init(spawned) do
    tree = [ worker(spawned, [], restart: :temporary) ]
    supervise(tree, strategy: :simple_one_for_one)
  end
end
 
defmodule ETSSupervisor.Sup do
  @moduledoc false
 
  use Supervisor.Behaviour
 
  def start_link(name, spawned) do
    :supervisor.start_link(__MODULE__, { name, spawned })
  end
 
  def init({ name, spawned }) do
    tree = [
      worker(ETSSupervisor, [name]),
      supervisor(ETSSupervisor.Spawner, [name.Spawner, spawned])
    ]
    supervise(tree, strategy: :one_for_one)
  end
end
